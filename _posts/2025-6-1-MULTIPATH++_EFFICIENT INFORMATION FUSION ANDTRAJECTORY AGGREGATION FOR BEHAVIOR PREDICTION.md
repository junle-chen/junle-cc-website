---
~
---
MultiPath++ 通过以下几个关键升级来应对这些挑战：

- 放弃了基于栅格化和 CNN 的方法，转而直接从紧凑的状态描述中建模稀疏世界状态对象 。
    
- 引入了一种新颖的上下文感知融合形式，称为多上下文门控（MCG） 。
    
- 开发了一种学习潜在锚点嵌入的方式，以简化模型创建并提高性能 。
    
- 通过应用集成技术获得了显著的额外收益 。

交互代理编码的目的是捕捉被建模代理周围动态的邻居代理集合之间的相互作用 。

MultiPath++ 模型从高层次上看与 MultiPath 相似，都包括一个编码步骤和一个预测器头部 。

- **输入：** MultiPath++ 接收以下模态的输入：
    - **代理状态历史：** 描述代理在过去固定步数内的轨迹序列。在 Waymo Open Motion 数据集中，这包括位置、速度、3D 边界框大小、航向角和对象类型；Argoverse 数据集仅提供位置信息。这些状态信息被转换到以代理为中心的坐标系 。
        
    - **道路图多段线：** 道路网络元素（如车道线、人行横道和停车线）被表示为分段线性段或多段线 。
        
    - **AV 状态历史：** 自主车辆/传感车辆（AV）相对于其他代理的特征 。
        
- **编码器：**
    - **代理历史编码：** 通过对过去 H 个时间步到当前时间的历史特征进行 LSTM 处理，对历史特征差异进行 LSTM 处理，以及对历史元素集应用 MCG 块来获得 。
        
    - **代理交互编码：** 对于每个被建模的代理，通过考虑每个相邻代理的过去状态观测值来构建交互编码。将相邻代理的状态转换到被建模代理的坐标系中，并使用 LSTM 进行嵌入。然后使用堆叠的 MCG 块融合邻居信息 。
        
    - **道路网络编码：** 将最接近的 128 条多段线转换到代理的参考系中，并表示代理与路段的空间关系。这些特征向量通过共享的 MLP 处理，生成每条路段的代理特定嵌入，然后使用堆叠的 MCG 块将其与代理历史嵌入融合 。
        
- **预测器：** 预测器模块的目标是预测 GMM 的参数。它以编码器的输出（结合了交互、道路和状态信息的特征向量）作为上下文，对学习到的锚点嵌入进行操作，并通过最终的 MLP 预测 GMM 的所有参数 。
    
- **输出：** MultiPath++ 预测一个以高斯混合模型（GMM）参数化的未来行为分布。每个时间步长的每个模式都表示为一个高斯分布，具有均值和协方差。分类头部预测模式的似然，回归头部输出高斯分布的参数 。
    

**3. 多上下文门控 (MCG) 机制**

- **融合模态：** MCG 是一种高效的信息融合机制。给定一组元素 s1:N​ 和一个输入上下文向量 c，CG 块为集合中的每个元素分配一个输出 s1:N′​，并计算一个输出上下文向量 c′ 。
    
- **置换不变性与等变性：** MCG 满足置换不变性（输出上下文向量与输入元素顺序无关）和置换等变性（输出元素是输入元素的置换） 。
    
- **实现：** 单个 CG 块通过 MLP、元素乘法（⊙）和池化层（如最大池化或平均池化）实现。多个 CG 块通过残差网络中使用的运行平均跳跃连接堆叠 。
    
- **与注意力的比较：** MCG 可以被视为交叉注意力的一种近似。与交叉注意力中每个元素都关注所有其他元素（O(n^2) 操作）不同，MCG 通过单个上下文向量 c 总结集合，从而提高计算效率 。
    

**4. 内部轨迹表示**

- MultiPath++ 预测代理的未来位置和航向，以及代理相关的纵向和横向高斯不确定性 。
    
- **状态序列：** 文献中最流行的方法是直接预测在均匀时间离散化下的状态序列 。
    
- **多项式表示：** 可以将随时间变化的函数表示为多项式，这增加了平滑轨迹的归纳偏置，并提供紧凑、可解释的表示 。
    
- **运动学控制信号：** 模型可以预测基础的运动学控制信号（如加速度 a(t) 和航向变化率 θ˙(t)），然后将其积分以恢复轨迹。这种表示增加了基于实际运动学和与预测代理当前状态一致的归纳偏置 。
    

**5. 通过引导聚合进行预测器集成**

- **集成目的：** 集成是一种强大的技术，通过结合多个互补的模型来获得更高容量和更低统计方差的模型 。
    
- **方法：** 通过训练 E 个预测器头部，并随机初始化权重，每个示例以 50% 的概率更新每个头部的权重，以鼓励模型学习互补信息 。
    
- **GMM 聚合：** 由于每个预测器头部输出的是高斯混合模型，且混合成分之间没有对应关系，因此聚合具有挑战性 。MultiPath++ 将集成结果的组合问题表述为贪婪迭代聚类问题，使用期望最大化（EM）算法最大化概率目标 。
    
- **目标多样性：** 聚合的目标是找到一个 M 模式的紧凑 GMM，使其能够最大化一个样本在一定距离内落入至少一个选定质心的概率，这明确优化了轨迹多样性，适用于漏报率（MR）和平均精度（mAP）等指标 。
    

**6. 训练目标**

- MultiPath++ 遵循原始 MultiPath 的方法，通过选择与真实轨迹欧氏距离最小的混合成分作为“正确”混合成分，最大化真实轨迹在模型预测分布下的似然性 。
    
- 使用 Adam 优化器，初始学习率为 0.0002，批次大小为 64，每 2 个 epoch 衰减学习率 0.5。模型训练 800,000 步 。




**具体步骤如下：**

1. **提取邻居代理状态观测值：** 对于每个被建模的代理，模型会考虑其所有邻居代理 v 的过去状态观测值：$\{x_{-H}^\nu, x_{-H+1}^\nu, \dots, x_{-1}^\nu, x_0^\nu\}$ 。
    
2. **转换到建模代理的坐标系：** 每个邻居代理 v 的状态会被转换到被建模代理的坐标系中。这包括相对方向、距离、历史和速度等特征 。
    
3. **LSTM 嵌入：** 转换后的邻居代理状态使用 LSTM 进行嵌入，以获得一个“交互嵌入” 。这与自我代理历史嵌入类似，但应用于其他代理的相对坐标 。
    
4. **MCG 融合邻居信息：** 对于 n 个邻居代理，会获得一组交互嵌入$\phi_{i=1 : n}^{\left( i n t e r a c t i o n \right)}$​。这些嵌入通过堆叠的 MCG 块进行融合 。
    
    - 融合的 MCG 操作表示为：$( \phi_{1 : n}^{\prime( i n t e r a c t i o n )}, \phi^{\prime( s t a t e )} )=$$M C G_{N} ( \phi_{1 : n}^{( i n t e r a c t i o n )}, [ \phi^{( s t a t e )}, \phi_{A V}^{( i n t e r a c t i o n )} ] )$
        
    - **输入：** MCG 的第一个参数是邻居交互嵌入集 $\phi_{1 : n}^{( i n t e r a c t i o n )}$。
        
    - **上下文：** MCG 的第二个参数是输入上下文向量，它是一个拼接的向量，包含被建模代理的历史嵌入 (ϕ(state)) 和 AV 的交互嵌入 (ϕAV(interaction)​) 。
        
    - **强调 AV：** 这种方式强调了 AV 在所有交互中作为独特实体的重要性 。
        

通过这种方式，模型能够捕捉到被建模代理与其周围邻居代理之间复杂的、以代理为中心的交互信息。