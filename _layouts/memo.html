---
layout: page
---

<!-- Optional: Load local token for development (file is in .gitignore) -->
<script src="{{ '/assets/js/memo-token.js' | relative_url }}" onerror="console.log('No local token file')"></script>

{{ content }}

<div class="memo-container">
  <div class="add-memo-section">
    <div class="section-header">
      <h3>‚ú® Add New Memo</h3>
      <button class="btn-settings" onclick="toggleGithubSettings()" title="GitHub Settings">
        ‚öôÔ∏è
      </button>
      <p class="text-muted">Record your ideas, tasks and important notes ¬∑ Public memos auto-sync to GitHub</p>
    </div>
    <form id="memoForm">
      <div class="form-group">
        <label for="memoTitle">üìå Title</label>
        <input type="text" id="memoTitle" class="form-control" placeholder="Give your memo a title..." />
      </div>
      <div class="form-group">
        <label for="memoContent">üìù Content</label>
        <textarea id="memoContent" class="form-control" rows="4" placeholder="Enter your memo content... Supports multiple lines"></textarea>
      </div>
      <div class="form-row">
        <div class="form-group col-md-4">
          <label for="memoCategory">üè∑Ô∏è Category</label>
          <select id="memoCategory" class="form-control">
            <option value="general">üìã General</option>
            <option value="todo">‚úÖ Todo</option>
            <option value="idea">üí° Idea</option>
            <option value="note">üìñ Note</option>
          </select>
        </div>
        <div class="form-group col-md-4">
          <label for="memoPriority">‚≠ê Priority</label>
          <select id="memoPriority" class="form-control">
            <option value="normal">Normal</option>
            <option value="important">Important</option>
            <option value="urgent">Urgent</option>
          </select>
        </div>
        <div class="form-group col-md-4">
          <label for="memoVisibility">üîí Visibility</label>
          <select id="memoVisibility" class="form-control">
            <option value="public" selected>üåç Public (sync to server)</option>
            <option value="private">üîê Private (local only)</option>
          </select>
        </div>
      </div>
      <div class="form-group">
        <label>üìé Attachments</label>
        <div class="attachment-section">
          <div class="file-upload-area">
            <input type="file" id="imageUpload" accept="image/*" multiple style="display: none;" />
            <button type="button" class="btn btn-outline-secondary btn-sm" onclick="document.getElementById('imageUpload').click()">
              üñºÔ∏è Add Images
            </button>
            <input type="file" id="fileUpload" multiple style="display: none;" />
            <button type="button" class="btn btn-outline-secondary btn-sm" onclick="document.getElementById('fileUpload').click()">
              üìÑ Add Files
            </button>
            <span class="upload-hint">Multiple files supported</span>
          </div>
          <div id="attachmentPreview" class="attachment-preview"></div>
        </div>
      </div>
      <button type="submit" class="btn btn-primary btn-lg btn-block">
        <span>‚ûï Add Memo</span>
      </button>
    </form>
    <div id="addMemoMessage"></div>
    
    <!-- GitHub Settings Panel (right sidebar) -->
    <div class="github-settings" id="githubSettings" style="display: none;">
      <h5>
        <span>‚öôÔ∏è GitHub Settings</span>
        <button class="close-btn" onclick="toggleGithubSettings()" title="Close">‚úï</button>
      </h5>
      <div class="form-group">
        <label for="githubToken">GitHub Personal Access Token</label>
        <input type="password" id="githubToken" class="form-control" placeholder="github_pat_..." />
        <small class="form-text">
          Need a token? <a href="https://github.com/settings/tokens/new?scopes=repo&description=Memo%20Sync" target="_blank">Create one here</a> (select "repo" scope)
        </small>
      </div>
      <div class="form-group">
        <label for="githubBranch">Branch</label>
        <input type="text" id="githubBranch" class="form-control" value="master" />
      </div>
      <div class="form-group">
        <label>
          <input type="checkbox" id="autoSync" checked /> Auto-sync public memos to GitHub
        </label>
      </div>
      <button type="button" class="btn btn-primary" onclick="saveGithubSettings()">üíæ Save Settings</button>
      <button type="button" class="btn btn-outline-secondary" onclick="testGithubConnection()">üîó Test Connection</button>
      <div id="githubSettingsMessage"></div>
    </div>
  </div>

  <div class="memos-list">
    <div class="list-header">
      <h3>üìö My Memos</h3>
      <div class="stats">
        <span id="memoCount" class="badge badge-info">0 memos</span>
        <span id="publicCount" class="badge badge-success">0 public</span>
        <span id="privateCount" class="badge badge-warning">0 private</span>
      </div>
    </div>
    
    <div class="filter-section">
      <div class="filter-buttons">
        <button class="filter-btn active" data-category="all">All</button>
        <button class="filter-btn" data-category="general">üìã General</button>
        <button class="filter-btn" data-category="todo">‚úÖ Todo</button>
        <button class="filter-btn" data-category="idea">üí° Idea</button>
        <button class="filter-btn" data-category="note">üìñ Note</button>
      </div>
      <div class="visibility-filters" style="margin-top: 10px;">
        <button class="visibility-btn active" data-visibility="all">All</button>
        <button class="visibility-btn" data-visibility="public">üåç Public</button>
        <button class="visibility-btn" data-visibility="private">üîê Private</button>
      </div>
      <div class="search-box">
        <input type="text" id="searchInput" class="form-control" placeholder="üîç Search memos..." />
      </div>
    </div>
    
    <div id="memosDisplay">
      <!-- Memos will be rendered by JavaScript combining server and local data -->
    </div>
  </div>
</div>

<!-- Pass server-side public memos to JavaScript -->
<script id="server-memos-data" type="application/json">
{% if site.data.memos %}
{{ site.data.memos | jsonify }}
{% else %}
[]
{% endif %}
</script>

<!-- Old server-side rendering (kept as fallback for no-JS) -->
<noscript>
  <div class="memo-container">
    <div class="memos-list">
      <h3>üìö Public Memos (JavaScript Required for Full Features)</h3>
      {% if site.data.memos %}
        {% assign sorted_memos = site.data.memos | sort: 'date' | reverse %}
        {% for memo in sorted_memos %}
        <div class="memo-item priority-{{ memo.priority | default: 'normal' }}" data-category="{{ memo.category }}" data-id="{{ memo.id }}">
          <div class="memo-header">
            <div class="header-left">
              {% if memo.title %}
              <h5 class="memo-title">{{ memo.title }}</h5>
              {% else %}
              <h5 class="memo-title text-muted">Êó†Ê†áÈ¢òÂ§áÂøò</h5>
              {% endif %}
            </div>
            <div class="header-right">
              {% if memo.priority == 'urgent' %}
              <span class="priority-badge urgent">üî• Á¥ßÊÄ•</span>
              {% elsif memo.priority == 'important' %}
              <span class="priority-badge important">‚≠ê ÈáçË¶Å</span>
              {% endif %}
              <span class="memo-category badge-{{ memo.category }}">
                {% if memo.category == 'general' %}General
                {% elsif memo.category == 'todo' %}Todo
                {% elsif memo.category == 'idea' %}Idea
                {% elsif memo.category == 'note' %}Note
                {% else %}{{ memo.category }}{% endif %}
              </span>
            </div>
          </div>
          <div class="memo-content">{{ memo.content }}</div>
          {% if memo.images or memo.files %}
          <div class="memo-attachments">
            {% if memo.images %}
              <div class="images-grid">
                {% for image in memo.images %}
                <img src="{{ image }}" alt="attachment" class="attachment-image" onclick="openImageModal(this.src)" />
                {% endfor %}
              </div>
            {% endif %}
            {% if memo.files %}
              <div class="files-list">
                {% for file in memo.files %}
                <a href="{{ file.url }}" class="file-item" download="{{ file.name }}">
                  üìé {{ file.name }}
                </a>
                {% endfor %}
              </div>
            {% endif %}
          </div>
          {% endif %}
          <div class="memo-footer">
            <span class="memo-date">üïê {{ memo.date }}</span>
            <div class="memo-actions">
              <button class="btn-icon" onclick="toggleComplete({{ memo.id }})" title="Mark as complete">
                <span class="complete-icon">‚úì</span>
              </button>
              <button class="btn-icon" onclick="deleteMemo({{ memo.id }})" title="Delete">
                <span class="delete-icon">üóëÔ∏è</span>
              </button>
            </div>
          </div>
        </div>
        {% endfor %}
      {% else %}
        <div class="empty-state">
          <div class="empty-icon">üìù</div>
          <p>No memos yet</p>
          <p class="text-muted">Add your first memo now!</p>
        </div>
      {% endif %}
    </div>
  </div>
</noscript>

<!-- Image Modal -->
<div id="imageModal" class="image-modal" onclick="closeImageModal()">
  <span class="close-modal">&times;</span>
  <img class="modal-content" id="modalImage">
  <div id="caption"></div>
</div>

<style>
:root {
  --primary-color: #0288D1;
  --secondary-color: #6c757d;
  --success-color: #28a745;
  --danger-color: #dc3545;
  --warning-color: #ffc107;
  --info-color: #17a2b8;
  --light-bg: #f8f9fa;
  --card-shadow: 0 2px 12px rgba(0,0,0,0.08);
  --hover-shadow: 0 4px 20px rgba(0,0,0,0.15);
  --border-radius: 12px;
  --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.memo-container {
  max-width: 1000px;
  margin: 0 auto;
  padding: 20px;
}

/* Add Memo Section */
.add-memo-section {
  background: linear-gradient(135deg, #B3E5FC 0%, #81D4FA 100%);
  padding: 30px;
  border-radius: var(--border-radius);
  margin-bottom: 40px;
  box-shadow: var(--card-shadow);
  color: white;
}

.section-header {
  position: relative;
}

.section-header h3 {
  margin: 0 0 5px 0;
  font-size: 1.8em;
  font-weight: 600;
}

.section-header p {
  margin: 0 0 20px 0;
  opacity: 0.9;
}

.btn-settings {
  position: absolute;
  top: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.5);
  color: white;
  padding: 6px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1em;
  transition: var(--transition);
  line-height: 1;
}

.btn-settings:hover {
  background: rgba(255, 255, 255, 0.5);
  transform: rotate(90deg) scale(1.1);
}

.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
  font-size: 0.95em;
}

.form-control {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 8px;
  font-size: 1em;
  transition: var(--transition);
  background: rgba(255,255,255,0.95);
  color: #333;
  min-height: 48px;
  line-height: 1.5;
}

.form-control option {
  padding: 8px;
  line-height: 1.8;
}

.form-control:focus {
  outline: none;
  border-color: white;
  background: white;
  box-shadow: 0 0 0 3px rgba(255,255,255,0.2);
}

.form-row {
  display: flex;
  gap: 15px;
  margin-bottom: 20px;
}

.form-row .form-group {
  flex: 1;
  margin-bottom: 0;
}

.col-md-6 {
  flex: 1;
}

/* ÈôÑ‰ª∂‰∏ä‰º†Âå∫Âüü */
.attachment-section {
  background: rgba(255,255,255,0.1);
  padding: 15px;
  border-radius: 8px;
  border: 2px dashed rgba(255,255,255,0.3);
}

.file-upload-area {
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
  margin-bottom: 10px;
}

.btn-outline-secondary {
  background: rgba(255,255,255,0.2);
  border: 1px solid rgba(255,255,255,0.4);
  color: white;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  transition: var(--transition);
  font-size: 0.9em;
}

.btn-outline-secondary:hover {
  background: rgba(255,255,255,0.3);
  transform: translateY(-2px);
}

.upload-hint {
  font-size: 0.85em;
  opacity: 0.8;
}

.attachment-preview {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-top: 10px;
}

.preview-item {
  position: relative;
  background: rgba(255,255,255,0.2);
  padding: 8px 12px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9em;
}

.preview-item img {
  width: 50px;
  height: 50px;
  object-fit: cover;
  border-radius: 4px;
}

.preview-remove {
  cursor: pointer;
  margin-left: 5px;
  opacity: 0.7;
  transition: opacity 0.2s;
}

.preview-remove:hover {
  opacity: 1;
}

.btn-primary {
  background: white;
  color: #0288D1;
  border: none;
  padding: 14px 28px;
  border-radius: 8px;
  font-size: 1.1em;
  font-weight: 600;
  cursor: pointer;
  transition: var(--transition);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,0,0,0.2);
}

.btn-lg {
  width: 100%;
}

#addMemoMessage {
  margin-top: 15px;
  padding: 12px;
  border-radius: 6px;
  font-weight: 500;
  text-align: center;
  display: none;
}

#addMemoMessage.success {
  background: rgba(40, 167, 69, 0.2);
  border: 1px solid rgba(40, 167, 69, 0.4);
  display: block;
}

#addMemoMessage.error {
  background: rgba(220, 53, 69, 0.2);
  border: 1px solid rgba(220, 53, 69, 0.4);
  display: block;
}

/* Â§áÂøòÂΩïÂàóË°® */
.memos-list {
  margin-top: 40px;
}

.list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.list-header h3 {
  margin: 0;
  font-size: 1.8em;
  color: #333;
}

.stats .badge {
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 0.9em;
}

.badge-info {
  background: var(--info-color);
  color: white;
}

.badge-success {
  background: var(--success-color);
  color: white;
}

.badge-warning {
  background: var(--warning-color);
  color: #333;
}

.filter-section {
  background: white;
  padding: 20px;
  border-radius: var(--border-radius);
  margin-bottom: 20px;
  box-shadow: var(--card-shadow);
}

.filter-buttons {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-bottom: 15px;
}

.filter-btn {
  padding: 8px 18px;
  border: 2px solid #e0e0e0;
  background: white;
  border-radius: 20px;
  cursor: pointer;
  transition: var(--transition);
  font-size: 0.95em;
  font-weight: 500;
  color: #666;
}

.filter-btn:hover {
  border-color: var(--primary-color);
  color: var(--primary-color);
  transform: translateY(-2px);
}

.filter-btn.active {
  background: var(--primary-color);
  color: white;
  border-color: var(--primary-color);
}

.visibility-filters {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.visibility-btn {
  padding: 8px 18px;
  border: 2px solid #e0e0e0;
  background: white;
  border-radius: 20px;
  cursor: pointer;
  transition: var(--transition);
  font-size: 0.95em;
  font-weight: 500;
  color: #666;
}

.visibility-btn:hover {
  border-color: var(--success-color);
  color: var(--success-color);
  transform: translateY(-2px);
}

.visibility-btn.active {
  background: var(--success-color);
  color: white;
  border-color: var(--success-color);
}

.col-md-4 {
  flex: 1;
}

.search-box {
  margin-top: 15px;
}

.search-box .form-control {
  border: 2px solid #e0e0e0;
  background: #f8f9fa;
}

/* Â§áÂøòÂΩïÂç°Áâá */
.memo-item {
  background: white;
  border: 2px solid #f0f0f0;
  border-left: 4px solid var(--primary-color);
  border-radius: var(--border-radius);
  padding: 20px;
  margin-bottom: 20px;
  transition: var(--transition);
  position: relative;
  overflow: hidden;
}

.memo-item:hover {
  box-shadow: var(--hover-shadow);
  transform: translateY(-3px);
  border-left-width: 6px;
}

.memo-item.priority-urgent {
  border-left-color: var(--danger-color);
  background: linear-gradient(to right, rgba(220, 53, 69, 0.05) 0%, white 50%);
}

.memo-item.priority-important {
  border-left-color: var(--warning-color);
  background: linear-gradient(to right, rgba(255, 193, 7, 0.05) 0%, white 50%);
}

.memo-item.completed {
  opacity: 0.7;
  background: #f8f9fa;
}

.memo-item.completed .memo-content {
  text-decoration: line-through;
  color: #999;
}

.memo-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
  gap: 15px;
}

.header-left {
  flex: 1;
}

.header-right {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}

.memo-title {
  margin: 0;
  font-size: 1.3em;
  color: #333;
  font-weight: 600;
}

.visibility-badge {
  padding: 4px 10px;
  border-radius: 15px;
  font-size: 0.8em;
  font-weight: 600;
  white-space: nowrap;
}

.visibility-badge.public {
  background: rgba(40, 167, 69, 0.1);
  color: var(--success-color);
  border: 1px solid var(--success-color);
}

.visibility-badge.private {
  background: rgba(108, 117, 125, 0.1);
  color: var(--secondary-color);
  border: 1px solid var(--secondary-color);
}

.priority-badge {
  padding: 4px 10px;
  border-radius: 15px;
  font-size: 0.8em;
  font-weight: 600;
  white-space: nowrap;
}

.priority-badge.urgent {
  background: rgba(220, 53, 69, 0.1);
  color: var(--danger-color);
  border: 1px solid var(--danger-color);
}

.priority-badge.important {
  background: rgba(255, 193, 7, 0.1);
  color: #f57c00;
  border: 1px solid var(--warning-color);
}

.memo-category {
  padding: 4px 12px;
  border-radius: 15px;
  font-size: 0.85em;
  font-weight: 500;
  white-space: nowrap;
}

.badge-general { background: #6c757d; color: white; }
.badge-todo { background: #007bff; color: white; }
.badge-idea { background: #ffc107; color: #333; }
.badge-note { background: #28a745; color: white; }

.memo-content {
  margin: 15px 0;
  line-height: 1.7;
  white-space: pre-wrap;
  color: #555;
  font-size: 1.05em;
}

/* ÈôÑ‰ª∂ÊòæÁ§∫ */
.memo-attachments {
  margin: 15px 0;
  padding: 15px;
  background: #f8f9fa;
  border-radius: 8px;
}

.images-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 10px;
  margin-bottom: 10px;
}

.attachment-image {
  width: 100%;
  height: 150px;
  object-fit: cover;
  border-radius: 8px;
  cursor: pointer;
  transition: var(--transition);
}

.attachment-image:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.files-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.file-item {
  display: inline-block;
  padding: 8px 12px;
  background: white;
  border: 1px solid #dee2e6;
  border-radius: 6px;
  text-decoration: none;
  color: #333;
  transition: var(--transition);
  font-size: 0.95em;
}

.file-item:hover {
  background: var(--primary-color);
  color: white;
  transform: translateX(5px);
}

.memo-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #e0e0e0;
}

.memo-date {
  color: #999;
  font-size: 0.9em;
}

.memo-actions {
  display: flex;
  gap: 8px;
}

.btn-icon {
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 6px 10px;
  border-radius: 6px;
  transition: var(--transition);
  font-size: 1.2em;
}

.btn-icon:hover {
  background: #f0f0f0;
  transform: scale(1.1);
}

.complete-icon {
  color: var(--success-color);
}

.delete-icon {
  color: var(--danger-color);
}

.btn-sync {
  color: var(--info-color);
  font-size: 1.1em;
}

.btn-sync:hover {
  background: rgba(23, 162, 184, 0.1);
}

/* Á©∫Áä∂ÊÄÅ */
.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: #999;
}

.empty-icon {
  font-size: 4em;
  margin-bottom: 15px;
}

.empty-state p {
  font-size: 1.1em;
  margin: 5px 0;
}

/* ÂõæÁâáÊ®°ÊÄÅÊ°Ü */
.image-modal {
  display: none;
  position: fixed;
  z-index: 9999;
  padding-top: 60px;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.9);
  animation: fadeIn 0.3s;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal-content {
  margin: auto;
  display: block;
  max-width: 90%;
  max-height: 80%;
  border-radius: 8px;
  animation: zoomIn 0.3s;
}

@keyframes zoomIn {
  from { transform: scale(0.5); }
  to { transform: scale(1); }
}

.close-modal {
  position: absolute;
  top: 20px;
  right: 40px;
  color: #f1f1f1;
  font-size: 50px;
  font-weight: bold;
  cursor: pointer;
  transition: 0.3s;
}

.close-modal:hover {
  color: #bbb;
}

#caption {
  margin: auto;
  display: block;
  width: 80%;
  max-width: 700px;
  text-align: center;
  color: #ccc;
  padding: 10px 0;
}

/* GitHub Settings Panel */
.github-settings {
  position: fixed;
  top: 0;
  right: 0;
  width: 400px;
  height: 100vh;
  background: white;
  border-left: 3px solid #0288D1;
  padding: 30px;
  box-shadow: -4px 0 20px rgba(0,0,0,0.15);
  overflow-y: auto;
  z-index: 10000;
  animation: slideInRight 0.3s ease-out;
}

@keyframes slideInRight {
  from {
    transform: translateX(100%);
  }
  to {
    transform: translateX(0);
  }
}

.github-settings h5 {
  color: #0288D1;
  margin: 0 0 20px 0;
  font-size: 1.5em;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.github-settings .close-btn {
  background: transparent;
  border: none;
  color: #999;
  font-size: 1.5em;
  cursor: pointer;
  padding: 0;
  line-height: 1;
  transition: var(--transition);
}

.github-settings .close-btn:hover {
  color: #333;
  transform: rotate(90deg);
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.github-settings h5 {
  color: #0288D1;
  margin-bottom: 10px;
}

.github-settings .form-group {
  margin-bottom: 15px;
}

.github-settings .form-control {
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 8px 12px;
}

.github-settings .form-text {
  font-size: 0.85em;
  color: #666;
}

.github-settings .form-text a {
  color: #0288D1;
  text-decoration: none;
}

.github-settings .form-text a:hover {
  text-decoration: underline;
}

.github-settings .btn {
  margin-right: 10px;
  margin-top: 10px;
}

#githubSettingsMessage {
  padding: 10px;
  border-radius: 4px;
  display: none;
}

#githubSettingsMessage.success {
  background: rgba(40, 167, 69, 0.2);
  border: 1px solid rgba(40, 167, 69, 0.4);
  color: #28a745;
  display: block;
}

#githubSettingsMessage.error {
  background: rgba(220, 53, 69, 0.2);
  border: 1px solid rgba(220, 53, 69, 0.4);
  color: #dc3545;
  display: block;
}

/* ÂìçÂ∫îÂºèËÆæËÆ° */
@media (max-width: 768px) {
  .memo-container {
    padding: 10px;
  }
  
  .add-memo-section {
    padding: 20px;
  }
  
  .form-row {
    flex-direction: column;
    gap: 0;
  }
  
  .form-row .form-group {
    margin-bottom: 20px;
  }
  
  .memo-header {
    flex-direction: column;
    gap: 10px;
  }
  
  .header-right {
    width: 100%;
    justify-content: flex-start;
  }
  
  .filter-buttons {
    justify-content: center;
  }
  
  .images-grid {
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  }
  
  /* ÊâãÊú∫Á´ØËÆæÁΩÆÈù¢ÊùøÂÖ®Â±è */
  .github-settings {
    width: 100%;
    left: 0;
  }
}
</style>

<script>
// Use IndexedDB for larger file storage (supports MB to GB)
let db;
let localMemos = [];  // Private memos from IndexedDB
let serverMemos = [];  // Public memos from server (Jekyll)
let attachedImages = [];
let attachedFiles = [];

// GitHub Configuration
// Token is stored in browser's localStorage for security
// Users need to configure their own token on first use
const GITHUB_CONFIG = {
  owner: 'junle-chen',
  repo: 'junle-cc-website',
  branch: 'master',
  token: localStorage.getItem('github_token') || '',
  autoSync: localStorage.getItem('github_auto_sync') !== 'false'
};

// Load GitHub settings from localStorage
function loadGithubSettings() {
  const tokenInput = document.getElementById('githubToken');
  const autoSyncCheck = document.getElementById('autoSync');
  const branchInput = document.getElementById('githubBranch');
  
  if (tokenInput) tokenInput.value = GITHUB_CONFIG.token;
  if (autoSyncCheck) autoSyncCheck.checked = GITHUB_CONFIG.autoSync;
  if (branchInput) branchInput.value = GITHUB_CONFIG.branch;
  
  // Show warning if no token configured
  if (!GITHUB_CONFIG.token) {
    const settingsPanel = document.getElementById('githubSettings');
    if (settingsPanel) {
      settingsPanel.style.border = '2px solid #ffc107';
      settingsPanel.style.background = 'rgba(255, 193, 7, 0.05)';
    }
    showGithubMessage('‚ö†Ô∏è Please configure your GitHub token to enable sync', 'error');
  }
}

// Save GitHub settings to localStorage
function saveGithubSettings() {
  const token = document.getElementById('githubToken').value.trim();
  const branch = document.getElementById('githubBranch').value.trim();
  const autoSync = document.getElementById('autoSync').checked;
  
  if (!token) {
    showGithubMessage('‚ö†Ô∏è Please enter a GitHub token', 'error');
    return;
  }
  
  localStorage.setItem('github_token', token);
  localStorage.setItem('github_branch', branch);
  localStorage.setItem('github_auto_sync', autoSync);
  
  GITHUB_CONFIG.token = token;
  GITHUB_CONFIG.branch = branch;
  GITHUB_CONFIG.autoSync = autoSync;
  
  // Reset panel styling
  const settingsPanel = document.getElementById('githubSettings');
  if (settingsPanel) {
    settingsPanel.style.border = '';
    settingsPanel.style.background = '';
  }
  
  showGithubMessage('‚úÖ Settings saved successfully! You can now sync memos.', 'success');
}

// Toggle GitHub settings panel
function toggleGithubSettings() {
  const panel = document.getElementById('githubSettings');
  if (panel) {
    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
  }
}

// Show GitHub settings message
function showGithubMessage(msg, type) {
  const msgDiv = document.getElementById('githubSettingsMessage');
  if (!msgDiv) return;
  
  msgDiv.textContent = msg;
  msgDiv.className = type;
  msgDiv.style.display = 'block';
  
  setTimeout(() => {
    if (type === 'success') {
      msgDiv.style.display = 'none';
    }
  }, 5000);
}

// Test GitHub connection
async function testGithubConnection() {
  const token = document.getElementById('githubToken').value.trim();
  
  if (!token) {
    showGithubMessage('Please enter a GitHub token first', 'error');
    return;
  }
  
  try {
    const response = await fetch(`https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github+json',
        'X-GitHub-Api-Version': '2022-11-28'
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      showGithubMessage(`‚úì Connection successful! Repository: ${data.full_name}`, 'success');
    } else {
      const error = await response.json();
      showGithubMessage(`‚úó Connection failed: ${error.message}`, 'error');
    }
  } catch (error) {
    showGithubMessage(`‚úó Connection failed: ${error.message}`, 'error');
  }
}

// Sync memo to GitHub
async function syncMemoToGithub(memo) {
  if (!GITHUB_CONFIG.token) {
    console.log('No GitHub token configured, skipping sync');
    return { success: false, error: 'No token configured' };
  }
  
  if (memo.visibility !== 'public') {
    console.log('Memo is private, skipping sync');
    return { success: true, skipped: true };
  }
  
  try {
    // 1. Read current _data/memos.yml
    const memosYmlPath = '_data/memos.yml';
    let currentContent = '';
    let currentSha = '';
    
    try {
      const getResponse = await fetch(
        `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${memosYmlPath}?ref=${GITHUB_CONFIG.branch}`,
        {
          headers: {
            'Authorization': `Bearer ${GITHUB_CONFIG.token}`,
            'Accept': 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28'
          }
        }
      );
      
      if (getResponse.ok) {
        const data = await getResponse.json();
        currentSha = data.sha;
        currentContent = atob(data.content);
      } else {
        const errorData = await getResponse.json();
        console.log('Error reading file:', errorData);
      }
    } catch (e) {
      console.log('memos.yml not found, will create new file');
    }
    
    // 2. Parse current memos
    let memos = [];
    if (currentContent) {
      // Simple YAML parsing (assuming our format)
      const lines = currentContent.split('\n');
      let currentMemo = null;
      
      for (const line of lines) {
        if (line.startsWith('- id:')) {
          if (currentMemo) memos.push(currentMemo);
          currentMemo = { id: parseInt(line.split(':')[1].trim()) };
        } else if (currentMemo) {
          const match = line.match(/^\s+(\w+):\s*(.+)$/);
          if (match) {
            const [, key, value] = match;
            currentMemo[key] = value.replace(/^["']|["']$/g, '');
          }
        }
      }
      if (currentMemo) memos.push(currentMemo);
    }
    
    // 3. Add or update memo
    const existingIndex = memos.findIndex(m => m.id === memo.id);
    const memoForYaml = {
      id: memo.id,
      title: memo.title || 'Untitled',
      content: memo.content,
      category: memo.category,
      priority: memo.priority,
      visibility: memo.visibility,
      date: memo.date,
      completed: memo.completed || false
    };
    
    if (existingIndex >= 0) {
      memos[existingIndex] = memoForYaml;
    } else {
      memos.unshift(memoForYaml);
    }
    
    // 4. Convert to YAML
    let yamlContent = '# Public Memos\n# Auto-generated - Do not edit manually\n\n';
    memos.forEach(m => {
      yamlContent += `- id: ${m.id}\n`;
      yamlContent += `  title: "${m.title}"\n`;
      yamlContent += `  content: "${m.content.replace(/\n/g, '\\n').replace(/"/g, '\\"')}"\n`;
      yamlContent += `  category: ${m.category}\n`;
      yamlContent += `  priority: ${m.priority}\n`;
      yamlContent += `  visibility: ${m.visibility}\n`;
      yamlContent += `  date: "${m.date}"\n`;
      yamlContent += `  completed: ${m.completed}\n\n`;
    });
    
    // 5. Save images to assets/images/memos/
    if (memo.images && memo.images.length > 0) {
      for (let i = 0; i < memo.images.length; i++) {
        const imgData = memo.images[i];
        const imgPath = `assets/images/memos/${memo.id}_${i}.png`;
        
        try {
          const base64Data = imgData.split(',')[1];
          const imgResponse = await fetch(
            `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${imgPath}`,
            {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${GITHUB_CONFIG.token}`,
                'Accept': 'application/vnd.github+json',
                'X-GitHub-Api-Version': '2022-11-28',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                message: `Add image for memo ${memo.id}`,
                content: base64Data,
                branch: GITHUB_CONFIG.branch
              })
            }
          );
          
          if (!imgResponse.ok) {
            const imgError = await imgResponse.json();
            console.error('Image upload error:', imgError);
          }
        } catch (e) {
          console.error('Error uploading image:', e);
        }
      }
    }
    
    // 6. Update memos.yml (ÈáçÊñ∞Ëé∑ÂèñÊúÄÊñ∞SHA‰ª•ÈÅøÂÖçÂÜ≤Á™Å)
    let latestSha = currentSha;
    if (currentSha) {
      try {
        const refreshResponse = await fetch(
          `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${memosYmlPath}?ref=${GITHUB_CONFIG.branch}`,
          {
            headers: {
              'Authorization': `Bearer ${GITHUB_CONFIG.token}`,
              'Accept': 'application/vnd.github+json',
              'X-GitHub-Api-Version': '2022-11-28'
            }
          }
        );
        if (refreshResponse.ok) {
          const refreshData = await refreshResponse.json();
          latestSha = refreshData.sha;
        }
      } catch (e) {
        console.log('Could not refresh SHA, using cached version');
      }
    }
    
    const updateResponse = await fetch(
      `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${memosYmlPath}`,
      {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${GITHUB_CONFIG.token}`,
          'Accept': 'application/vnd.github+json',
          'X-GitHub-Api-Version': '2022-11-28',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message: `Add/Update memo: ${memo.title || 'Untitled'}`,
          content: btoa(unescape(encodeURIComponent(yamlContent))),
          sha: latestSha || undefined,
          branch: GITHUB_CONFIG.branch
        })
      }
    );
    
    if (updateResponse.ok) {
      return { success: true };
    } else {
      const error = await updateResponse.json();
      console.error('Update error details:', error);
      return { success: false, error: error.message || JSON.stringify(error) };
    }
    
  } catch (error) {
    console.error('GitHub sync error:', error);
    return { success: false, error: error.message };
  }
}

// Initialize IndexedDB
async function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('MemoDB', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('memos')) {
        db.createObjectStore('memos', { keyPath: 'id' });
      }
    };
  });
}

// Load memos from IndexedDB
async function loadMemos() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['memos'], 'readonly');
    const objectStore = transaction.objectStore('memos');
    const request = objectStore.getAll();
    
    request.onsuccess = () => {
      localMemos = request.result.sort((a, b) => b.id - a.id);
      resolve(localMemos);
    };
    request.onerror = () => reject(request.error);
  });
}

// Save memo to IndexedDB
async function saveMemo(memo) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['memos'], 'readwrite');
    const objectStore = transaction.objectStore('memos');
    const request = objectStore.add(memo);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Delete memo from IndexedDB
async function deleteMemoFromDB(id) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['memos'], 'readwrite');
    const objectStore = transaction.objectStore('memos');
    const request = objectStore.delete(id);
    
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

// Update memo in IndexedDB
async function updateMemo(memo) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['memos'], 'readwrite');
    const objectStore = transaction.objectStore('memos');
    const request = objectStore.put(memo);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// Image upload handler
document.getElementById('imageUpload').addEventListener('change', function(e) {
  const files = Array.from(e.target.files);
  files.forEach(file => {
    if (file.type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onload = function(event) {
        attachedImages.push({
          name: file.name,
          data: event.target.result,
          type: file.type
        });
        updateAttachmentPreview();
      };
      reader.readAsDataURL(file);
    }
  });
});

// File upload handler
document.getElementById('fileUpload').addEventListener('change', function(e) {
  const files = Array.from(e.target.files);
  files.forEach(file => {
    const reader = new FileReader();
    reader.onload = function(event) {
      attachedFiles.push({
        name: file.name,
        data: event.target.result,
        type: file.type,
        size: formatFileSize(file.size)
      });
      updateAttachmentPreview();
    };
    reader.readAsDataURL(file);
  });
});

// Update attachment preview
function updateAttachmentPreview() {
  const preview = document.getElementById('attachmentPreview');
  preview.innerHTML = '';
  
  attachedImages.forEach((img, index) => {
    const div = document.createElement('div');
    div.className = 'preview-item';
    div.innerHTML = `
      <img src="${img.data}" alt="${img.name}" />
      <span>${img.name}</span>
      <span class="preview-remove" onclick="removeAttachment('image', ${index})">‚úï</span>
    `;
    preview.appendChild(div);
  });
  
  attachedFiles.forEach((file, index) => {
    const div = document.createElement('div');
    div.className = 'preview-item';
    div.innerHTML = `
      <span>üìé ${file.name} (${file.size})</span>
      <span class="preview-remove" onclick="removeAttachment('file', ${index})">‚úï</span>
    `;
    preview.appendChild(div);
  });
}

// Remove attachment
function removeAttachment(type, index) {
  if (type === 'image') {
    attachedImages.splice(index, 1);
  } else {
    attachedFiles.splice(index, 1);
  }
  updateAttachmentPreview();
}

// Format file size
function formatFileSize(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

// Add memo form submit handler
document.getElementById('memoForm').addEventListener('submit', async function(e) {
  e.preventDefault();
  
  console.log('Form submitted');
  
  const title = document.getElementById('memoTitle').value.trim();
  const content = document.getElementById('memoContent').value.trim();
  const category = document.getElementById('memoCategory').value;
  const priority = document.getElementById('memoPriority').value;
  const visibility = document.getElementById('memoVisibility').value;
  
  console.log('Form values:', { title, content, category, priority, visibility });
  
  if (!content && attachedImages.length === 0 && attachedFiles.length === 0) {
    showMessage('Please enter content or add attachments', 'error');
    return;
  }
  
  const memo = {
    id: Date.now(),
    title: title || null,
    content: content,
    category: category,
    priority: priority,
    visibility: visibility,
    date: new Date().toLocaleString('en-US', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    }),
    images: attachedImages.length > 0 ? attachedImages.map(img => img.data) : null,
    files: attachedFiles.length > 0 ? attachedFiles.map(f => ({
      name: f.name,
      data: f.data,
      size: f.size
    })) : null,
    completed: false
  };
  
  try {
    console.log('Saving memo:', memo);
    
    // Show initial message BEFORE any async operations
    if (GITHUB_CONFIG.autoSync && memo.visibility === 'public') {
      showMessage('üíæ Saving memo and syncing to GitHub...', 'success', false);
    }
    
    // Save to IndexedDB
    await saveMemo(memo);
    localMemos.unshift(memo);
    console.log('Memo saved successfully');
    
    // Auto-sync to GitHub if enabled and memo is public
    if (GITHUB_CONFIG.autoSync && memo.visibility === 'public') {
      const syncResult = await syncMemoToGithub(memo);
      
      if (syncResult.success) {
        showMessage('‚úÖ Memo added and synced to GitHub successfully! It will appear on your website in 1-2 minutes.', 'success', true);
      } else if (syncResult.skipped) {
        showMessage('‚úÖ Private memo added successfully (saved locally only)', 'success', true);
      } else {
        showMessage('‚ö†Ô∏è Memo saved locally, but GitHub sync failed: ' + syncResult.error + '. Please check your connection or token.', 'error', true);
      }
    } else if (visibility === 'private') {
      showMessage('‚úÖ Private memo added successfully (saved locally only)', 'success', true);
    } else {
      // Fallback (shouldn't happen with current config)
      showMessage('‚úÖ Memo added successfully!', 'success', true);
    }
    
    // Clear form
    document.getElementById('memoTitle').value = '';
    document.getElementById('memoContent').value = '';
    document.getElementById('memoCategory').value = 'general';
    document.getElementById('memoPriority').value = 'normal';
    document.getElementById('memoVisibility').value = 'public';
    attachedImages = [];
    attachedFiles = [];
    updateAttachmentPreview();
    
    displayMemos();
    updateStats();
  } catch (error) {
    console.error('Error saving memo:', error);
    showMessage('‚ùå Error saving memo: ' + error.message, 'error');
  }
});

// Show message
let messageTimer = null;
function showMessage(msg, type, autoHide = true) {
  const msgDiv = document.getElementById('addMemoMessage');
  msgDiv.textContent = msg;
  msgDiv.className = type;
  msgDiv.style.display = 'block';
  
  // Clear previous timer
  if (messageTimer) {
    clearTimeout(messageTimer);
    messageTimer = null;
  }
  
  // Auto hide after delay if specified
  if (autoHide) {
    const displayTime = msg.includes('synced') || msg.includes('failed') ? 5000 : 3000;
    messageTimer = setTimeout(() => {
      msgDiv.className = '';
      msgDiv.style.display = 'none';
      messageTimer = null;
    }, displayTime);
  }
}

// Display memos
let currentVisibility = 'all';

function displayMemos(filter = 'all', searchText = '') {
  const display = document.getElementById('memosDisplay');
  
  // Merge server memos (public) and local memos (private)
  // Server memos are already public, local memos may be public or private
  const privateMemos = localMemos.filter(m => m.visibility === 'private');
  const allMemos = [...serverMemos, ...privateMemos];
  
  let filteredMemos = allMemos;
  
  // Filter by category
  if (filter !== 'all') {
    filteredMemos = filteredMemos.filter(m => m.category === filter);
  }
  
  // Filter by visibility
  if (currentVisibility !== 'all') {
    filteredMemos = filteredMemos.filter(m => (m.visibility || 'public') === currentVisibility);
  }
  
  // Filter by search
  if (searchText) {
    const search = searchText.toLowerCase();
    filteredMemos = filteredMemos.filter(m => 
      (m.title && m.title.toLowerCase().includes(search)) ||
      (m.content && m.content.toLowerCase().includes(search))
    );
  }
  
  if (filteredMemos.length === 0) {
    display.innerHTML = `
      <div class="empty-state">
        <div class="empty-icon">üîç</div>
        <p>No memos found</p>
        <p class="text-muted">Try different filters or search criteria</p>
      </div>
    `;
    return;
  }
  
  display.innerHTML = filteredMemos.map(memo => {
    const priorityBadge = memo.priority === 'urgent' ? '<span class="priority-badge urgent">üî• Urgent</span>' :
                         memo.priority === 'important' ? '<span class="priority-badge important">‚≠ê Important</span>' : '';
    
    const visibilityBadge = (memo.visibility || 'public') === 'private' ? 
      '<span class="visibility-badge private">üîê Private</span>' :
      '<span class="visibility-badge public">üåç Public</span>';
    
    const syncButton = (memo.visibility || 'public') === 'public' ? 
      `<button class="btn-icon btn-sync" onclick="showSyncCommand(${memo.id})" title="Sync to server">
        <span>‚òÅÔ∏è</span>
      </button>` : '';
    
    const imagesHtml = memo.images ? `
      <div class="images-grid">
        ${memo.images.map(img => `<img src="${img}" alt="attachment" class="attachment-image" onclick="openImageModal('${img}')" />`).join('')}
      </div>
    ` : '';
    
    const filesHtml = memo.files ? `
      <div class="files-list">
        ${memo.files.map(file => `
          <a href="${file.data}" class="file-item" download="${file.name}">
            üìé ${file.name} ${file.size ? '(' + file.size + ')' : ''}
          </a>
        `).join('')}
      </div>
    ` : '';
    
    const attachmentsHtml = (imagesHtml || filesHtml) ? `
      <div class="memo-attachments">
        ${imagesHtml}
        ${filesHtml}
      </div>
    ` : '';
    
    return `
      <div class="memo-item priority-${memo.priority || 'normal'} ${memo.completed ? 'completed' : ''}" 
           data-category="${memo.category}" 
           data-visibility="${memo.visibility || 'public'}"
           data-id="${memo.id}">
        <div class="memo-header">
          <div class="header-left">
            <h5 class="memo-title">${memo.title || 'Untitled Memo'}</h5>
          </div>
          <div class="header-right">
            ${visibilityBadge}
            ${priorityBadge}
            <span class="memo-category badge-${memo.category}">${getCategoryName(memo.category)}</span>
          </div>
        </div>
        ${memo.content ? `<div class="memo-content">${memo.content}</div>` : ''}
        ${attachmentsHtml}
        <div class="memo-footer">
          <span class="memo-date">üïê ${memo.date}</span>
          <div class="memo-actions">
            <button class="btn-icon" onclick="toggleComplete(${memo.id})" title="Mark as complete">
              <span class="complete-icon">${memo.completed ? '‚Ü∫' : '‚úì'}</span>
            </button>
            <button class="btn-icon" onclick="deleteMemo(${memo.id})" title="Delete">
              <span class="delete-icon">üóëÔ∏è</span>
            </button>
          </div>
        </div>
      </div>
    `;
  }).join('');
}

// Get category name
function getCategoryName(category) {
  const names = {
    general: 'üìã General',
    todo: '‚úÖ Todo',
    idea: 'üí° Idea',
    note: 'üìñ Note'
  };
  return names[category] || category;
}

// Show sync command
async function showSyncCommand(memoId) {
  const memo = localMemos.find(m => m.id === memoId);
  if (!memo) return;
  
  // If GitHub token is configured, use API sync
  if (GITHUB_CONFIG.token) {
    if (confirm('Sync this memo to GitHub now?')) {
      showMessage('Syncing to GitHub...', 'success');
      const result = await syncMemoToGithub(memo);
      
      if (result.success) {
        showMessage('‚úì Memo synced to GitHub successfully!', 'success');
      } else {
        showMessage('‚úó Sync failed: ' + result.error, 'error');
      }
    }
  } else {
    // Fallback to manual command
    const memoJson = JSON.stringify(memo);
    const command = `echo '${memoJson.replace(/'/g, "'\\''")}' | ruby sync_memo.rb sync`;
    
    prompt(
      `No GitHub token configured.\n\nOption 1: Configure token in ‚öôÔ∏è GitHub Settings for automatic sync\n\nOption 2: Run this command manually:\n\n${command}`,
      command
    );
  }
}

// Update stats
function updateStats() {
  const privateMemos = localMemos.filter(m => m.visibility === 'private');
  const totalCount = serverMemos.length + privateMemos.length;
  
  document.getElementById('memoCount').textContent = `${totalCount} memo${totalCount !== 1 ? 's' : ''}`;
  document.getElementById('publicCount').textContent = `${serverMemos.length} public`;
  document.getElementById('privateCount').textContent = `${privateMemos.length} private`;
}

// Toggle completion status
async function toggleComplete(id) {
  const memo = localMemos.find(m => m.id === id);
  if (memo) {
    memo.completed = !memo.completed;
    try {
      await updateMemo(memo);
      displayMemos();
      updateStats();
    } catch (error) {
      console.error('Error updating memo:', error);
    }
  }
}

// Delete memo
async function deleteMemo(id) {
  if (confirm('Are you sure you want to delete this memo?')) {
    try {
      await deleteMemoFromDB(id);
      localMemos = localMemos.filter(m => m.id !== id);
      showMessage('‚úì Memo deleted', 'success');
      displayMemos();
      updateStats();
    } catch (error) {
      console.error('Error deleting memo:', error);
      showMessage('Error deleting memo', 'error');
    }
  }
}

// Open image modal
function openImageModal(src) {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  modal.style.display = 'block';
  modalImg.src = src;
}

// Close image modal
function closeImageModal() {
  document.getElementById('imageModal').style.display = 'none';
}

// Filter buttons
document.querySelectorAll('.filter-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    const category = this.getAttribute('data-category');
    const searchText = document.getElementById('searchInput').value;
    displayMemos(category, searchText);
  });
});

// Visibility filter buttons
document.querySelectorAll('.visibility-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.visibility-btn').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    currentVisibility = this.getAttribute('data-visibility');
    const category = document.querySelector('.filter-btn.active').getAttribute('data-category');
    const searchText = document.getElementById('searchInput').value;
    displayMemos(category, searchText);
  });
});

// Search function
document.getElementById('searchInput').addEventListener('input', function(e) {
  const activeFilter = document.querySelector('.filter-btn.active').getAttribute('data-category');
  displayMemos(activeFilter, e.target.value);
});

// Initialize display
document.addEventListener('DOMContentLoaded', async function() {
  try {
    // Load GitHub settings
    loadGithubSettings();
    
    // Load server-side public memos from Jekyll
    const serverDataElement = document.getElementById('server-memos-data');
    if (serverDataElement) {
      try {
        serverMemos = JSON.parse(serverDataElement.textContent || '[]');
        console.log('‚úì Loaded', serverMemos.length, 'public memos from server');
      } catch (e) {
        console.error('Error parsing server memos:', e);
        serverMemos = [];
      }
    }
    
    // Initialize database and load private memos
    await initDB();
    await loadMemos();
    displayMemos();
    updateStats();
    document.querySelector('.filter-btn[data-category="all"]').classList.add('active');
    document.querySelector('.visibility-btn[data-visibility="all"]').classList.add('active');
    
    // Show auto-sync status
    if (GITHUB_CONFIG.autoSync && GITHUB_CONFIG.token) {
      console.log('‚úì GitHub auto-sync enabled');
    }
  } catch (error) {
    console.error('Error initializing app:', error);
    // Fallback to localStorage if IndexedDB fails
    localMemos = JSON.parse(localStorage.getItem('memos') || '[]');
    displayMemos();
    updateStats();
    document.querySelector('.filter-btn[data-category="all"]').classList.add('active');
    document.querySelector('.visibility-btn[data-visibility="all"]').classList.add('active');
  }
});
</script>
